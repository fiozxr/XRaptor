#!/usr/bin/env bash
# XRaptor installer + main script bundle
# This single file contains the XRaptor protection script, systemd unit, and installer steps.
# Save this whole file as xraptor-installer.sh, make executable and run as root to install.

set -euo pipefail

########################################
# Installer wrapper - writes files to system
########################################
INSTALLER_PATH="/tmp/xraptor-installer.$$"
MAIN_BIN="/usr/local/bin/xraptor.sh"
SERVICE_FILE="/etc/systemd/system/xraptor.service"
CONF_DIR="/etc/xraptor"
LOG_DIR="/var/log/xraptor"
RUN_DIR="/var/run/xraptor"

cat > "$MAIN_BIN" <<'XRAPTOR_SCRIPT'
#!/usr/bin/env bash
# XRaptor - real-time SSH/port-scan protector (lightweight, fail2ban-style)
# Author: generated by ChatGPT for user

set -euo pipefail
shopt -s extglob
if [ -z "${BASH_VERSINFO:-}" ] || (( BASH_VERSINFO[0] < 4 )); then
  echo "bash >= 4 required. Current: ${BASH_VERSION}"
  exit 1
fi

################################
# CONFIG - edit these values
################################
LOG_FILE="/var/log/auth.log"            # auth log to watch (adjust for distro)
THRESHOLD=5                             # failed attempts within WINDOW => block
WINDOW=600                              # sliding window (seconds) for counting attempts (default 10min)
BAN_TIME=3600                           # block duration in seconds (default 1 hour)
STATE_FILE="/var/run/xraptor/state.txt"    # stores active bans: "<epoch> <IP>"
BLOCK_LIST="/var/log/xraptor/blocked_ips.txt"    # persistent blocked IPs
JSON_LOG="/var/log/xraptor/events.json"   # JSON event log (append)
WHITELIST_FILE="/etc/xraptor/whitelist.txt"   # one IP per line
MANUAL_BLACKLIST="/etc/xraptor/manual_blacklist.txt" # manual blocks to ensure persistency

# Port-scan detection
DETECT_PORTSCAN=true
PORT_SCAN_THRESHOLD=6      # unique destination ports within PORT_SCAN_WINDOW => block
PORT_SCAN_WINDOW=120       # seconds window to consider for port-scan detection

# Alerts - set tokens/webhooks (leave blank to disable)
TELEGRAM_BOT_TOKEN=""      # example: "123456:ABC-DEF..."
TELEGRAM_CHAT_ID=""        # example: "-1001234567890"
DISCORD_WEBHOOK_URL=""     # example webhook URL
EMAIL_FROM="xraptor@example.com"
EMAIL_TO=""                # recipient email; leave blank to disable email alerts

# Runtime options
UNBLOCK_CHECK_INTERVAL=60   # seconds: how often background thread checks for expired bans
DEBUG=false

################################
# End CONFIG
################################

# Prepare directories & files
mkdir -p "$(dirname "$STATE_FILE")"
mkdir -p "$(dirname "$BLOCK_LIST")"
mkdir -p "$(dirname "$JSON_LOG")"
mkdir -p "$(dirname "$WHITELIST_FILE")"
mkdir -p "$(dirname "$MANUAL_BLACKLIST")"

touch "$STATE_FILE" "$BLOCK_LIST" "$JSON_LOG"
touch "$WHITELIST_FILE"
touch "$MANUAL_BLACKLIST"

# Root check
if [ "$(id -u)" -ne 0 ]; then
  echo "Please run as root."
  exit 1
fi

# Load whitelist into associative set for quick check
declare -A WHITELIST
while IFS= read -r ip; do
  [[ -z "$ip" || "$ip" =~ ^# ]] && continue
  WHITELIST["$ip"]=1
done < "$WHITELIST_FILE"

# Load manual blacklist persistently (will be applied on start)
while IFS= read -r ip; do
  [[ -z "$ip" || "$ip" =~ ^# ]] && continue
  if ! grep -q -x "$ip" "$BLOCK_LIST"; then
    echo "$ip" >> "$BLOCK_LIST"
  fi
done < "$MANUAL_BLACKLIST"

# Apply persistent blocklist entries (if not already applied)
apply_persistent_blocks() {
  while IFS= read -r ip; do
    [[ -z "$ip" || "$ip" =~ ^# ]] && continue
    if ! iptables -C INPUT -s "$ip" -j DROP &>/dev/null ; then
      iptables -A INPUT -s "$ip" -j DROP
      echo "[INIT-BLOCK] $ip"
    fi
  done < "$BLOCK_LIST"
}
apply_persistent_blocks

# Associate arrays for attempt tracking
declare -A ATTEMPTS      # ATTEMPTS[$ip] = comma-separated timestamps
declare -A PORTS        # PORTS[$ip] = "port:timestamp;port2:timestamp;..."

# State helper functions
now_ts() { date +%s; }

log_json() {
  local type="$1"; shift
  local msg="$*"
  local ts
  ts=$(date --iso-8601=seconds)
  jq -n --arg t "$ts" --arg ty "$type" --arg m "$msg" \
    '{time:$t,type:$ty,message:$m}' >> "$JSON_LOG" 2>/dev/null || \
    echo "{\"time\":\"$ts\",\"type\":\"$type\",\"message\":\"$msg\"}" >> "$JSON_LOG"
}

# Alerts
send_telegram() {
  if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then return; fi
  local text="$1"
  curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
    -d chat_id="$TELEGRAM_CHAT_ID" -d parse_mode="Markdown" -d text="$text" >/dev/null 2>&1 || true
}

send_discord() {
  if [ -z "$DISCORD_WEBHOOK_URL" ]; then return; fi
  local content="$1"
  curl -s -H "Content-Type: application/json" -d "{\"content\":\"$(printf '%s' "$content" | sed 's/"/\\"/g')\"}" \
    "$DISCORD_WEBHOOK_URL" >/dev/null 2>&1 || true
}

send_email() {
  if [ -z "$EMAIL_TO" ]; then return; fi
  local subject="$1"
  local body="$2"
  {
    echo "From: $EMAIL_FROM"
    echo "To: $EMAIL_TO"
    echo "Subject: $subject"
    echo
    echo "$body"
  } | sendmail -t || true
}

alert_all() {
  local title="$1"
  local body="$2"
  log_json "alert" "$title — $body"
  send_telegram "*XRaptor alert*\n$title\n\`\`\`\n$body\n\`\`\`"
  send_discord "$title — $body"
  send_email "XRaptor: $title" "$body"
}

# Blocking & unblocking
block_ip() {
  local ip="$1"
  if [[ -n "${WHITELIST[$ip]:-}" ]]; then
    $DEBUG && echo "whitelisted $ip, skipping block"
    return
  fi
  if iptables -C INPUT -s "$ip" -j DROP &>/dev/null ; then
    $DEBUG && echo "$ip already dropped"
  else
    iptables -A INPUT -s "$ip" -j DROP
  fi
  local ts
  ts=$(now_ts)
  echo "$ts $ip" >> "$STATE_FILE"
  if ! grep -q -x "$ip" "$BLOCK_LIST"; then
    echo "$ip" >> "$BLOCK_LIST"
  fi
  alert_all "Blocked IP $ip" "Blocked for suspicious activity. IP: $ip"
  log_json "block" "$ip"
}

unblock_ip() {
  local ip="$1"
  if iptables -C INPUT -s "$ip" -j DROP &>/dev/null ; then
    iptables -D INPUT -s "$ip" -j DROP || true
    log_json "unblock" "$ip"
    alert_all "Unblocked IP $ip" "Ban time expired. IP: $ip"
  fi
}

# Background cleanup loop
cleanup_loop() {
  while true; do
    sleep "$UNBLOCK_CHECK_INTERVAL"
    NOW=$(now_ts)
    if [ -f "$STATE_FILE" ]; then
      tmp=$(mktemp)
      while read -r ts ip; do
        [[ -z "$ts" || -z "$ip" ]] && continue
        if (( NOW - ts >= BAN_TIME )); then
          unblock_ip "$ip"
        else
          echo "$ts $ip" >> "$tmp"
        fi
      done < "$STATE_FILE"
      mv "$tmp" "$STATE_FILE"
    fi
  done
}

prune_attempts_for_ip() {
  local ip="$1"; local window="$WINDOW"
  local now; now=$(now_ts)
  local kept=""
  local IFS=,
  read -ra arr <<< "${ATTEMPTS[$ip]:-}"
  for t in "${arr[@]}"; do
    [[ -z "$t" ]] && continue
    if (( now - t <= window )); then
      if [[ -z "$kept" ]]; then kept="$t"; else kept="$kept,$t"; fi
    fi
  done
  ATTEMPTS[$ip]="$kept"
  if [[ -z "$kept" ]]; then
    echo 0
  else
    echo $(( $(awk -F',' '{print NF}' <<< "$kept") ))
  fi
}

record_and_check_ports() {
  local ip="$1"; local port="$2"
  local now; now=$(now_ts)
  local raw="${PORTS[$ip]:-}"
  local new=""
  IFS=';' read -ra pairs <<< "$raw"
  declare -A unique_ports=()
  for p in "${pairs[@]}"; do
    [[ -z "$p" ]] && continue
    port_i="${p%%:*}"
    ts_i="${p##*:}"
    if (( now - ts_i <= PORT_SCAN_WINDOW )); then
      unique_ports["$port_i"]="$ts_i"
    fi
  done
  unique_ports["$port"]="$now"
  for k in "${!unique_ports[@]}"; do
    new+="$k:${unique_ports[$k]};"
  done
  PORTS[$ip]="$new"
  echo "${#unique_ports[@]}"
}

dbg() { $DEBUG && echo "[DEBUG]" "$@"; }

# Start cleanup loop in background
cleanup_loop &

echo "[START] XRaptor watching $LOG_FILE ..."
log_json "start" "xraptor started"

# apply manual blacklist as active blocks
while IFS= read -r ip; do
  [[ -z "$ip" || "$ip" =~ ^# ]] && continue
  if ! grep -q -x "$ip" "$BLOCK_LIST"; then
    echo "$ip" >> "$BLOCK_LIST"
  fi
  if ! iptables -C INPUT -s "$ip" -j DROP &>/dev/null ; then
    iptables -A INPUT -s "$ip" -j DROP
  fi
done < "$MANUAL_BLACKLIST"

# Main tail loop
tail -Fn0 "$LOG_FILE" | while IFS= read -r line; do
  if echo "$line" | grep -qE "Failed password|authentication failure|Invalid user"; then
    IP=""
    PORT=""
    if echo "$line" | grep -q " rhost="; then
      IP=$(sed -n 's/.*rhost=\([0-9.]*\).*/\1/p' <<<"$line" | head -n1)
    fi
    if [[ -z "$IP" ]]; then
      IP=$(awk '{ for(i=1;i<=NF;i++) if ($i == "from") print $(i+1) }' <<<"$line" | head -n1 || true)
    fi
    if [[ -z "$PORT" ]]; then
      PORT=$(awk '{ for(i=1;i<=NF;i++) if ($i == "port") print $(i+1) }' <<<"$line" | head -n1 || true)
    fi
    if [[ ! "$IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      dbg "couldn't parse IP from: $line"
      continue
    fi

    dbg "failed attempt from $IP port $PORT"

    if [[ -n "${WHITELIST[$IP]:-}" ]]; then
      dbg "ignored whitelisted $IP"
      continue
    fi

    ts=$(now_ts)
    cur="${ATTEMPTS[$IP]:-}"
    if [[ -z "$cur" ]]; then
      ATTEMPTS[$IP]="$ts"
    else
      ATTEMPTS[$IP]="$cur,$ts"
    fi

    COUNT=$(prune_attempts_for_ip "$IP")
    dbg "count for $IP => $COUNT"

    if [ "$DETECT_PORTSCAN" = true ] && [[ -n "$PORT" && "$PORT" =~ ^[0-9]+$ ]]; then
      UNIQUE_PORTS=$(record_and_check_ports "$IP" "$PORT")
      dbg "unique ports for $IP => $UNIQUE_PORTS"
      if (( UNIQUE_PORTS >= PORT_SCAN_THRESHOLD )); then
        echo "[DETECT] Port-scan from $IP (unique ports: $UNIQUE_PORTS)"
        block_ip "$IP"
        continue
      fi
    fi

    if (( COUNT >= THRESHOLD )); then
      if ! grep -q -E "^[0-9]+ $IP$" "$STATE_FILE"; then
        block_ip "$IP"
      else
        dbg "$IP already in state file"
      fi
    fi

    log_json "failed_attempt" "ip=$IP count=$COUNT port=${PORT:-unknown} line=$(echo "$line" | sed 's/"/'\''/g' | cut -c1-400)"
  fi
done
XRAPTOR_SCRIPT

# systemd unit
cat > "$SERVICE_FILE" <<'SERVICE'
[Unit]
Description=XRaptor - lightweight SSH/port-scan protector
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/xraptor.sh
Restart=on-failure
User=root

[Install]
WantedBy=multi-user.target
SERVICE

# Create config & log dirs
mkdir -p "$CONF_DIR"
mkdir -p "$LOG_DIR"
mkdir -p "$RUN_DIR"

# default whitelist & manual blacklist
touch "$CONF_DIR/whitelist.txt"
touch "$CONF_DIR/manual_blacklist.txt"

# move state file path used by script
mkdir -p "$(dirname "$STATE_FILE")"

# fix permissions
chmod 755 "$MAIN_BIN"
chown root:root "$MAIN_BIN"

# reload systemd and enable service
systemctl daemon-reload
systemctl enable --now xraptor.service || true

cat <<'DONE'
XRaptor installed.
Files written:
 - /usr/local/bin/xraptor.sh (main script)
 - /etc/systemd/system/xraptor.service (systemd unit)
 - /etc/xraptor/whitelist.txt
 - /etc/xraptor/manual_blacklist.txt
Logs: /var/log/xraptor/events.json
State: /var/run/xraptor/state.txt

Important:
 - Edit /etc/xraptor/whitelist.txt and add your admin IP(s) before starting if you are installing remotely.
 - Configure alert webhooks/tokens inside /usr/local/bin/xraptor.sh in the CONFIG section.
 - If your system uses a different auth log (e.g., /var/log/secure on CentOS/RHEL), update LOG_FILE in the script.

To view live logs: sudo journalctl -u xraptor -f
To stop: sudo systemctl stop xraptor
To uninstall: sudo systemctl disable --now xraptor && rm -f /usr/local/bin/xraptor.sh /etc/systemd/system/xraptor.service && systemctl daemon-reload
DONE

echo "Installation complete."
echo " Don't Forget To Visit www.github.com/fiozxr "

# End of installer
